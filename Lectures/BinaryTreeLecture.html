<div class="mt-5 ml-5">
    <h2 class="text-center">Binary Tree</h2>
    <p>
        In computer science, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A recursive definition using just set theory notions is that a (non-empty) binary tree is a tuple (L, S, R), where L and R are binary trees or the empty set and S is a singleton set.Some authors allow the binary tree to be the empty set as well.

        From a graph theory perspective, binary (and K-ary) trees as defined here are actually arborescences. A binary tree may thus be also called a bifurcating arborescence —a term which appears in some very old programming books, before the modern computer science terminology prevailed. It is also possible to interpret a binary tree as an undirected, rather than a directed graph, in which case a binary tree is an ordered, rooted tree. Some authors use rooted binary tree instead of binary tree to emphasize the fact that the tree is rooted, but as defined above, a binary tree is always rooted. A binary tree is a special case of an ordered K-ary tree, where k is 2.

        In mathematics, what is termed binary tree can vary significantly from author to author. Some use the definition commonly used in computer science, but others define it as every non-leaf having exactly two children and don't necessarily order (as left/right) the children either.
    </p>
    <p>
        In computing, binary trees are used in two very different ways:
        <ol type="I">
            <li>First, as a means of accessing nodes based on some value or label associated with each node. Binary trees labelled this way are used to implement binary search trees and binary heaps, and are used for efficient searching and sorting. The designation of non-root nodes as left or right child even when there is only one child present matters in some of these applications, in particular it is significant in binary search trees.[10] However, the arrangement of particular nodes into the tree is not part of the conceptual information. For example, in a normal binary search tree the placement of nodes depends almost entirely on the order in which they were added, and can be re-arranged (for example by balancing) without changing the meaning.</li>
            <li> Second, as a representation of data with a relevant bifurcating structure. In such cases the particular arrangement of nodes under and/or to the left or right of other nodes is part of the information (that is, changing it would change the meaning). Common examples occur with Huffman coding and cladograms. The everyday division of documents into chapters, sections, paragraphs, and so on is an analogous example with n-ary rather than binary trees.</li>
        </ol>
        To actually define a binary tree in general, we must allow for the possibility that only one of the children may be empty. An artifact, which in some textbooks is called an extended binary tree is needed for that purpose. An extended binary tree is thus recursively defined as:

        the empty set is an extended binary tree
        if T1 and T2 are extended binary trees, then denote by T1 • T2 the extended binary tree obtained by adding a root r connected to the left to T1 and to the right to T2 by adding edges when these sub-trees are non-empty.
        Another way of imagining this construction (and understanding the terminology) is to consider instead of the empty set a different type of node—for instance square nodes if the regular ones are circles.
    </p>
    <h4>Using graph theory concepts</h4>
    <p>
        A binary tree is a rooted tree that is also an ordered tree (a.k.a. plane tree) in which every node has at most two children. A rooted tree naturally imparts a notion of levels (distance from the root), thus for every node a notion of children may be defined as the nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes possible to distinguish left child from right child.[13] But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child.

        The necessary distinction can be made by first partitioning the edges, i.e., defining the binary tree as triplet (V, E1, E2), where (V, E1 ∪ E2) is a rooted tree (equivalently arborescence) and E1 ∩ E2 is empty, and also requiring that for all j ∈ { 1, 2 } every node has at most one Ej child.[14] A more informal way of making the distinction is to say, quoting the Encyclopedia of Mathematics, that "every node has a left child, a right child, neither, or both" and to specify that these "are all different" binary trees.
    </p>
    <h4>Bonus Content</h4>
    <iframe width="853" height="480" src="https://www.youtube.com/embed/BHB0B1jFKQc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    <div class="mt-3">
        <h4>Syntax</h4>
        <h6><b>Implementation in Java</b></h6>
        <pre>
            <span class="text-capitalize">
                /* Class containing left and right child of current
                node and key value*/
                class Node
                {
                int key;
                Node left, right;

                public Node(int item)
                {
                key = item;
                left = right = null;
                }
                }

                // A Java program to introduce Binary Tree
                class BinaryTree
                {
                // Root of Binary Tree
                Node root;

                // Constructors
                BinaryTree(int key)
                {
                root = new Node(key);
                }

                BinaryTree()
                {
                root = null;
                }

                public static void main(String[] args)
                {
                BinaryTree tree = new BinaryTree();

                /*create root*/
                tree.root = new Node(1);

                /* following is the tree after above statement

                1
                / \
                null null	 */

                tree.root.left = new Node(2);
                tree.root.right = new Node(3);

                /* 2 and 3 become left and right children of 1
                1
                / \
                2	 3
                / \ / \
                null null null null */


                tree.root.left.left = new Node(4);
                /* 4 becomes left child of 2
                1
                /	 \
                2		 3
                / \	 / \
                4 null null null
                / \
                null null
                */
                }
                }

            </span>
            
        </pre>
        
       
        <hr class="bg-primary">
    </div>
</div>
