<div class="mt-5 ml-5">
    <h2 class="text-center">Heap</h2>
    <p>
        In computer science, a heap is a specialized tree-based data structure which is essentially an almost complete tree that satisfies the heap property: in a max heap, for any given node C, if P is a parent node of C, then the key (the value) of P is greater than or equal to the key of C. In a min heap, the key of P is less than or equal to the key of C. The node at the "top" of the heap (with no parents) is called the root node.

        The heap is one maximally efficient implementation of an abstract data type called a priority queue, and in fact priority queues are often referred to as "heaps", regardless of how they may be implemented. In a heap, the highest (or lowest) priority element is always stored at the root. However, a heap is not a sorted structure; it can be regarded as being partially ordered. A heap is a useful data structure when it is necessary to repeatedly remove the object with the highest (or lowest) priority.

        A common implementation of a heap is the binary heap, in which the tree is a binary tree. The heap data structure, specifically the binary heap, was introduced by J. W. J. Williams in 1964, as a data structure for the heapsort sorting algorithm. Heaps are also crucial in several efficient graph algorithms such as Dijkstra's algorithm. When a heap is a complete binary tree, it has a smallest possible height—a heap with N nodes and for each node a branches always has loga N height.

        Note that there is no implied ordering between siblings or cousins and no implied sequence for an in-order traversal (as there would be in, e.g., a binary search tree). The heap relation mentioned above applies only between nodes and their parents, grandparents, etc. The maximum number of children each node can have depends on the type of heap.
    </p>
    <h4>Operations</h4>
    <p>
        The common operations involving heaps are:
        <br />

        <h5>Basic</h5>
        <ol type="I">
            <li>
                find-max (or find-min): find a maximum item of a max-heap, or a minimum item of a min-heap, respectively (a.k.a. peek)
            </li>
            <li>
                insert: adding a new key to the heap (a.k.a., push)
            </li>
            <li>
                extract-max (or extract-min): returns the node of maximum value from a max heap [or minimum value from a min heap] after removing it from the heap (a.k.a., pop)
            </li>
            <li>
                delete-max (or delete-min): removing the root node of a max heap (or min heap), respectively
            </li>
            <li>
                replace: pop root and push a new key. More efficient than pop followed by push, since only need to balance once, not twice, and appropriate for fixed-size heaps.
            </li>
        </ol>


        <h5>Creation</h5>
        <ol type="I">
            <li>create-heap: create an empty heap</li>
            <li> heapify: create a heap out of given array of elements</li>
            <li> merge (union): joining two heaps to form a valid new heap containing all the elements of both, preserving the original heaps.</li>
            <li> meld: joining two heaps to form a valid new heap containing all the elements of both, destroying the original heaps.</li>
        </ol>

        <h5>Inspection</h5>
        <ol type="I">
            <li>size: return the number of items in the heap.</li>
            <li>is-empty: return true if the heap is empty, false otherwise.</li>
        </ol>

        <h5>Internal</h5>
        <ol type="I">
            <li>
                increase-key or decrease-key: updating a key within a max- or min-heap, respectively
            </li>
            <li>
                delete: delete an arbitrary node (followed by moving last node and sifting to maintain heap)
            </li>
            <li>
                sift-up: move a node up in the tree, as long as needed; used to restore heap condition after insertion. Called "sift" because node moves up the tree until it reaches the correct level, as in a sieve.
            </li>
            <li>
                sift-down: move a node down in the tree, similar to sift-up; used to restore heap condition after deletion or replacement.
            </li>
        </ol>

        <h4>Implementation</h4>
        Heaps are usually implemented in an array (fixed size or dynamic array), and do not require pointers between elements. After an element is inserted into or deleted from a heap, the heap property may be violated and the heap must be balanced by internal operations.
        Binary heaps may be represented in a very space-efficient way (as an implicit data structure) using an array alone. The first (or last) element will contain the root. The next two elements of the array contain its children. The next four contain the four children of the two child nodes, etc. Thus the children of the node at position n would be at positions 2n and 2n + 1 in a one-based array, or 2n + 1 and 2n + 2 in a zero-based array. This allows moving up or down the tree by doing simple index computations. Balancing a heap is done by sift-up or sift-down operations (swapping elements which are out of order). As we can build a heap from an array without requiring extra memory (for the nodes, for example), heapsort can be used to sort an array in-place.

        Different types of heaps implement the operations in different ways, but notably, insertion is often done by adding the new element at the end of the heap in the first available free space. This will generally violate the heap property, and so the elements are then sifted up until the heap property has been reestablished. Similarly, deleting the root is done by removing the root and then putting the last element in the root and sifting down to rebalance. Thus replacing is done by deleting the root and putting the new element in the root and sifting down, avoiding a sifting up step compared to pop (sift down of last element) followed by push (sift up of new element).

        Construction of a binary (or d-ary) heap out of a given array of elements may be performed in linear time using the classic Floyd algorithm, with the worst-case number of comparisons equal to 2N − 2s2(N) − e2(N) (for a binary heap), where s2(N) is the sum of all digits of the binary representation of N and e2(N) is the exponent of 2 in the prime factorization of N.This is faster than a sequence of consecutive insertions into an originally empty heap, which is log-linear.
        The C++ Standard Library provides the make_heap, push_heap and pop_heap algorithms for heaps (usually implemented as binary heaps), which operate on arbitrary random access iterators. It treats the iterators as a reference to an array, and uses the array-to-heap conversion. It also provides the container adaptor priority_queue, which wraps these facilities in a container-like class. However, there is no standard support for the replace, sift-up/sift-down, or decrease/increase-key operations.
        The Boost C++ libraries include a heaps library. Unlike the STL, it supports decrease and increase operations, and supports additional types of heap: specifically, it supports d-ary, binomial, Fibonacci, pairing and skew heaps.
        There is a generic heap implementation for C and C++ with D-ary heap and B-heap support. It provides an STL-like API.
        The standard library of the D programming language includes std.container.BinaryHeap, which is implemented in terms of D's ranges. Instances can be constructed from any random-access range. BinaryHeap exposes an input range interface that allows iteration with D's built-in foreach statements and integration with the range-based API of the std.algorithm package.
        The Java platform (since version 1.5) provides a binary heap implementation with the class java.util.PriorityQueue in the Java Collections Framework. This class implements by default a min-heap; to implement a max-heap, programmer should write a custom comparator. There is no support for the replace, sift-up/sift-down, or decrease/increase-key operations.
        Python has a heap module that implements a priority queue using a binary heap. The library exposes a heapreplace function to support k-way merging.
        PHP has both max-heap (SplMaxHeap) and min-heap (SplMinHeap) as of version 5.3 in the Standard PHP Library.
        Perl has implementations of binary, binomial, and Fibonacci heaps in the Heap distribution available on CPAN.
        The Go language contains a heap package with heap algorithms that operate on an arbitrary type that satisfies a given interface. That package does not support the replace, sift-up/sift-down, or decrease/increase-key operations.
        Apple's Core Foundation library contains a CFBinaryHeap structure.
        Pharo has an implementation of a heap in the Collections-Sequenceable package along with a set of test cases. A heap is used in the implementation of the timer event loop.
        The Rust programming language has a binary max-heap implementation, BinaryHeap, in the collections module of its standard library.
    </p>
    <iframe width="853" height="480" src="https://www.youtube.com/embed/t0Cq6tVNRBA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>